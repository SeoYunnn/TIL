# 프로젝트를 위한 WebSocket 학습
- 해당 파일은, NestJS로 채팅방 구현 프로젝트를 위한 WebSocket 학습 내용 정리 공간입니다

<br>

## 💭 WebSocket 이란 ?
📢 WebSocket : 웹 소켓 프로토콜은 HTTP 와는 다른 통신 프로토콜로, 웹 서버와 웹 브라우저가 실시간 메세지를 교환하는 데에 사용됨
<br> 👉🏻 클라이언트와 서버를 연결하고, 언제든 양방향 통신 또는 데이터 전송 가능


<br>

웹 소켓 연결을 맺기 위한 첫 번째 핸드셰이크를 주고 받은 이후, 지속적으로 연결됨

매번 메세지 전송 시에 **새롭게 연결을 맺을 필요가 없음** ***👉🏻 빠르고 효율적***

<br>

웹 소켓은 TCP 소켓과 이름만 유사할 뿐 브라우저의 소켓이며, 웹 소켓 프로토콜은 HTTP 와 동일하게 애플리케이션 계층에서 동작함

평문 메세지 전송 방식으로, SSL/TLS 보안 계층으로 암호화되어야 **데이터 탈취를 방지할 수 있음**

웹에서도 채팅이나, 게임, 실시간 주식 차트와 같이 실시간이 요구되는 응용 프로그램의 개발을 한 층 효과적으로 구현할 수 있게 되었음

<br>
<br>

## 💭 WebSocket 특징
### 1. 양방향 통신

> *데이터의 송수신을 동시에 처리할 수 있는 방법*
>

통상적인 HTTP 통신은 클라이언트가 요청을 보내는 경우에만 서버가 응답을 하는 단방향 통신

**But, *웹 소켓은 양방향 통신이 가능***

<br>
<br>


### 2. 실시간 네트워킹

> *웹 환경에서 연속된 데이터를 빠르게 노출하는 것*
>
>
> *ex) 채팅, 주식*
>

<br>
<br>

### 3. 저렴한 오버헤드

> *비교적 낮은 오버헤드를 갖고 있어, 효율적 통신 가능*
>

<br>
<br>

### 4. 표준 프로토콜

> *웹 소켓은 `HTML5` 표준의 일부로써, 다양한 웹 브라우저와 서버 플랫폼에서 지원됨*
>

<br>
<br>

## 💭 WebSocket 동작 과정
<img width="679" alt="image" src="https://github.com/SeoYunnn/TIL/assets/120713987/5d3289c1-981e-49c9-9f75-c62736d1c05f">

👉🏻 빨간색 박스에 해당하는 `Opening Handshake` (연결 설정)

👉🏻 노란색 박스에 해당하는 `Data transfer`

👉🏻 보라색 박스에 해당하는 `Closing Handshake` (연결 해제)


<br>
<br>

**(1) Opening Handshaking (연결 설정)**

- 클라이언트가 서버에게 웹 소켓 연결을 요청함 👉🏻 일반적으로, HTTP 프로토콜을 사용해 이루어짐
- 클라이언트가 웹 소켓 `handshake` 요청을 서버에게 전송함 👉🏻 HTTP 의 Upgrade 헤더 필드를 사용해 업그레이드 요청임을 알려줌
- 서버는 요청을 받으면, 클라이언트의 요청을 수락하고 웹 소켓을 열 준비를 함

  👉🏻 HTTP `101` 상태 코드 반환(Switching Protocols)

- 열림을 확인한 후, 웹 소켓 프로토콜을 통해 데이터를 주고받을 수 있음

<br>

**(2) Data Transfer (데이터 전송)**

- 연결이 설정된 후에는 클라이언트와 서버 간에 데이터를 주고받을 수 있음
- 클라이언트와 서버는 데이터를 프레임으로 나누어 전송하며, 웹 소켓 프로토콜에 정의된 형식에 따름
- 데이터가 전송되면 클라이언트와 서버는 이를 처리하고, 필요에 따라 응답을 생성해 다시 상대편으로 보냄

<br>

**(3) Closing Handshaking (연결 해제)**

- 웹 소켓 연결이 더 이상 필요하지 않을 때, 클라이언트나 서버는 연결을 닫기 위한 `handshaking` 과정을 수행함
- 클라이언트나 서버가 연결을 닫기 위해 `CLOSE` 메세지를 보내면, 상대편은 `CLOSE` 메세지를 받고 확인 응답을 반환함
- 이후 상대편도 `CLOSE` 메세지를 보내고, 양쪽에서 모두 연결이 닫혔음을 확인하면 웹 소켓 연결이 완전히 종료됨

<br>
<br>

## 💭 WebSocket 이전 통신 방식

웹 소켓이 나오기 이전에는 모두 클라이언트의 요청이 없다면, 서버로부터 응답을 받을 수 없는 구조

👉🏻 ***웹 소켓은 이러한 문제를 해결하는 새로운 약속***

<br>
<br>

### 1. Ajax(Asynchronous JavaScript and XML)

📢 ***Ajax : 비동기적으로 서버와 브라우저 간의 데이터를 교환하는 기술***

클라이언트 측에서 `JavaScript` 를 사용해 서버에 HTTP 요청을 보내고, 서버는 `XML`, `JSON` 또는 일반 텍스트 형식으로 응답함

**But,** `Ajax` 는 단방향 통신이므로 서버에서 데이터가 변경되었을 때 **실시간으로 반영하기 어려웠음**

<br>
<br>

### 2. Comet / Long Polling

**(1)Comet**

> *클라이언트에서 서버로의 연결을 열어두고, 서버에서 새로운 데이터가 있을 때까지 연결을 유지하는 방식*
>

<br>

**(2) Long Polling**

> *Comet 기술 중 하나로, 클라이언트가 서버에 요청을 보내면 서버는 새로운 데이터가 생길 때까지 연결을 유지한 상태에서 대기하다가, 새로운 데이터가 생기면 응답 반환*
>

이러한 방식들은, 실시간성을 흉내내기 위해 사용되었지만 **여전히 연결을 유지하고 대기하는 단점이 있음**

<br>
<br>

### 3. HTTP Streaming

📢 ***HTTP Streaming : 서버에서 데이터를 연속적으로 전송하는 방식***

<br>

서버는 클라이언트에게 데이터의 일부를 전송하고 연결을 유지한 채 대기함

클라이언트는 전송된 데이터를 처리하고 계속해서 새로운 데이터를 요청함

**But,** 연결을 오랫동안 유지하면서 서버의 부담을 증가시킬 수 있기 때문에 이러한 **연결 유지 오버헤드 문제가 발생함**

또한, 데이터를 작은 조각으로 전송하는데 클라이언트는 계속해서 데이터를 받으면서 추가적 네트워크 지연을 유발할 수 있으며 **메모리 소비량이 심할 수 있다는 단점 존재**

<br>
<br>

## 💭 WebSocket 단점
### 1. Cross Browser 문제

<img width="773" alt="image" src="https://github.com/SeoYunnn/TIL/assets/120713987/850a9aff-faff-4759-970c-324cc9a17696">

👉🏻 브라우저 중 버전에 따라 지원을 안 하는 경우도 존재

<br>
<br>

### 2. Stateful protocol

서버와 클라이언트 간의 연결을 항상 유지해야 하며 비정상적으로 연결이 끊어졌을 경우, 적절한 대응을 해줘야 함

이는 기존의 HTTP 사용시와 비교했을 때 코딩의 복잡성을 가중시키는 요인이 될 수 있음

<br>
<br>

### 3. 보안 취약

웹 소켓 연결은 기본적으로 암호화되지 않기 때문에 보안에 취약함

민감한 정보의 유출이나 보안 측면에서 신중하게 관리할 필요성이 있음

<br>
<br>

### **🤔 어떻게 안전하게 사용할 수 있을까 ?**

👉🏻 ***SSL / TLS 사용***

👉🏻 ***CSRF 토큰을 사용하거나, 웹 소켓 연결이 요청된 동일한 도메인에 제한***

👉🏻 `***Nginx` 사용 (웹 서버 뿐 아니라, 리버스 프록시 서버로도 사용)***

👉🏻 ***AWS 로드밸런서와 ACM 인증***

<br>
<br>

## 💭 WebSocket vs HTTP
### 1. HTTP

> **한계 ⇒ 사용자가 URL 을 요청할 경우에만 서버에서 응답**
>

기존 HTTP는 단방향 통신이었음

클라이언트에서 서버로 `Request` 를 보내면 서버는 클라이언트로 `Response` 를 보내는 방식으로 동작

또한, 기본적으로 **무상태**이므로 상태를 저장하지 않음

👉🏻 서버가 클라이언트의 상태값을 갖고있지 않음

👉🏻 실시간 연결이 아님

<br>
<br>

### 2. WebSocket

웹 소켓은 위에서도 말했듯이, **양방향 통신**이므로 연결이 이루어지면 클라이언트가 요청하지 않아도 데이터가 저절로 서버로부터 올 수 있음

HTTP 처럼 별도의 요청을 보내지 않아도 데이터를 수신할 수 있음

<br>
<br>

## 💭 Socket.io
📢 ***Socket.io : 양방향 통신을 하기 위해 웹 소켓 기술을 활용하는 `Node.js` 라이브러리***


|  | WebSocket 프로토콜 | Socket.io |
| --- | --- | --- |
| 프로토콜 | TCP 기반 프로토콜 | 웹 소켓 기반 라이브러리 |
| 지원 범위 | 웹 브라우저와 서버 간 통신을 위한 표준화된 프로토콜로, 대부분 최신 브라우저와 서버 환경에서 지원 | 웹 소켓을 지원하지 않는 구형 브라우저에서도 폴링과 같은 대안적 방법으로 통신 가능 |
| 지원 기능 | 실시간 양방향 통신을 위한 기본 메커니즘 제공 | 웹 소켓을 기반으로 하면서도 추가적 기능 제공 |

<br>
<br>

### 1. Namespace

> *`Express` 라우팅처럼 url 에 지정된 위치에 따라 신호의 처리를 다르게 하는 기술*
>

<img width="769" alt="image" src="https://github.com/SeoYunnn/TIL/assets/120713987/fa4b412b-0ca5-4e51-878f-ac6490b2b103">

서버와 클라이언트가 연결되면 실시간 데이터 공유가 가능한데, `socket` 을 그냥 사용하면 데이터가 모든 `socket` 으로 들어가게 됨

**But,** 특정 페이지에서 소켓이 보내주는 모든 실시간 메세지를 받을 필요는 없음

👉🏻 **불필요 및 낭비**

그렇기 때문에, 특정 노드끼리만 연결해주는 **Namespace** 를 사용함

👉🏻 지정한 **Namespace** 에 있는 소켓 끼리만 통신 가능

<br>
<br>

### 2. Room

> *Namespace의 하위 개념
**(IO → NameSpace → Room → Socket)***
>

<img width="774" alt="image" src="https://github.com/SeoYunnn/TIL/assets/120713987/c08cf3ae-e893-4743-9f3a-a8a3ef74839c">
<br>

예를 들어, 카톡 단톡방이 두 개 있다고 가정하자

A라는 단톡방에 메세지를 보내면, A단톡방에 사용자들은 메세지를 받지만, 다른 단톡방의 사용자들은 그 메세지를 받지 못함

소켓들의 룸도 단톡방과 비슷함

특정 룸에 신호를 보내면 룸 안의 소켓들은 신호를 받지만, 다른 룸에 소속된 소켓들은 신호를 받지 못함

<br>

이를 통해 room 에 `join` 되어 있는 클라이언트 만의 데이터 송수신이 가능하게 됨

👉🏻 ***각 클라이언트는 socket 을 갖게 되며, 이 socket 은 namespace 를 갖고, 각 namespace 는 room 을 가지게 됨***

네임스페이스를 통해 큰 줄기의 데이터 통신을 만들고 룸을 미세하게 소켓을 연결할 수 있음

<img width="661" alt="image" src="https://github.com/SeoYunnn/TIL/assets/120713987/08406c9e-75a6-4778-bdb4-608e02cf084b">

<img width="765" alt="image" src="https://github.com/SeoYunnn/TIL/assets/120713987/c4a5c453-09cc-455c-8d9c-7b406e208988">
네임스페이스와 방은 이러한 구조로 설계되어 있음

`join` , `leave` , `to` 등의 메서드를 사용해서 채팅방을 **참가/떠나다/~한테** 개념을 적용할 수 있음

<br>
<br>

### 3. Socket.io 에서 사용되는 메서드

(1) `join(room: string)`

- 클라이언트를 지정된 룸에 조인룸은 특정 그룹을 나타냄
- 해당 룸에 조인한 클라이언트는 해당 룸에 속함

<br>

(2) `leave(room: string)`

- 클라이언트가 지정된 룸을 떠남

<br>

(3) `emit(event: string, ...args: any[])`

- 클라이언트에 이벤트를 보냄
- 첫 번째 매개변수로 이벤트 이름을 지정하고, 두 번째 매개변수 이후로는 해당 이벤트 핸들러로 전달할 데이터를 지정

<br>

(4) `broadcast.emit(event: string, ...args: any[])`

- 현재 소켓을 제외한 모든 클라이언트에 이벤트를 보냄

<br>

(5) `to(room: string) / in(room: string)`

- 특정 룸에 속한 클라이언트에게 이벤트를 보냄

<br>

(6) `disconnect()`

- 클라이언트와의 연결을 종료함

<br>

(7) `on(event: string, listener: Function)`

- 클라이언트에서 특정 이벤트를 수신할 때 실행할 리스너를 등록함

<br>

(8) `once(event: string, listener: Function)`

- 한 번만 실행될 이벤트 리스너를 등록함

<br>

(9) `off(event: string, listener: Function)`

- 이벤트 리스너를 제거함

<br>

(10) `offAll()`

- 현재 소켓에 연결된 모든 이벤트 리스너를 제거함

<br>

(11) `use(fn: Function)`

- 미들웨어 함수를 등록함

<br>
<br>

### 4. 요약

> ***같은, 네임스페이스 안에서 소통해 소켓 송수신을 분리할 수 있고, 네임스페이스 안의 같은 룸 안에서만 소통하게 해, 더 세분하게 소켓 송수신을 분리할 수 있음***
>

<img width="685" alt="image" src="https://github.com/SeoYunnn/TIL/assets/120713987/b8ebf6b2-e670-4d23-ac18-98686cbe57f8">

- `Namespace <path>` : 전역에서 나눈 공간
- `룸ID` : 네임스페이스에서 세분히 나눈 공간
- `소켓ID` : 어느 특정 사용자와 소통용