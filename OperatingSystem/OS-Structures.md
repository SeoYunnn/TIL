# Chapter 02 운영체제 구조

## 💭 운영체제 서비스

📢  ***운영체제(Operation-System) : 프로그램 실행 환경을 제공하며, 프로그램과 그 프로그램의 사용자에게 특정 서비스를 제공***

<br>

![Untitled](https://github.com/SeoYunnn/TIL/assets/120713987/c0a0b1d5-6838-4197-bf63-d80eae93cf28)

그림처럼 다양한 운영체제 서비스에 대한 한 가지 관점과 그들의 상호 관계를 보여줌

이런 서비스는 프로그래머가 프로그래밍 작업을 더 쉽게 수행할 수 있도록 함

<br>
<br>

**1️⃣ 사용자 인터페이스(user interface)**

거의 모든 운영체제는 UI를 제공하며, 이 인터페이스는 여러 형태로 제공될 수 있음

👉🏻 가장 일반적으로는 **GUI**가 사용

인터페이스는 윈도 시스템으로 I/O를 지시하고, 메뉴에서 선택 후, 화면을 선택하는 포인팅 장치인 마우스와 텍스트를 입력할 키보드를 갖고 있음

👉🏻 휴대전화 및 태블릿과 같은 모바일 시스템은 **터치스크린 인터페이스**를 제공해 사용자가 화면의 버튼을 눌러 선택 항목을 선택할 수 있음

**CLI**는 명령을 사용해 입력할 방법(ex: 특정 옵션이 정해진 특정 형식으로 명령을 입력하기 위한 키보드) 이 사용됨

<br>
<br>

**2️⃣ 프로그램 수행(program execution)**

시스템은 프로그램을 메모리에 적재해 실행할 수 있어야 함

프로그램은 정상적이든, 비정상적이든(오류 표시) 실행을 끝낼 수 있어야 함

<br>
<br>

**3️⃣ 입출력 연산(I/O operation)**

수행 중인 프로그램은 입출력을 요구할 수 있음

👉🏻 파일 혹은, 입출력 장치가 연관될 수 있음

👉🏻 특정 장치에 대해서는 특수한 기능(네트워크 인터페이스에서 읽거나 파일 시스템에 쓰기 등)이 요구될 수 있음

효율과 보호를 위해, 사용자들은 통상 입출력 장치를 직접 제어할 수 없기 때문에, 운영체제가 입출력 수행의 수단을 제공해야 함

<br>
<br>

**4️⃣ 파일 시스템 조작(file system manipulation)**

프로그램은 파일을 읽고 쓸 필요가 있음

이름에 의해 파일을 생성하고, 삭제할 수 있고, 지정된 파일을 찾을 수 있어야 하고, 파일의 정보를 열거할 수 있어야 함

또한 몇몇 프로그램은 파일 소유권에 기반을 둔 권한 관리를 이용해 파일이나 디렉토리의 접근을 허가하거나 거부할 수 있게 함

<br>
<br>

**5️⃣ 통신(communication)**

한 프로세스가 다른 프로세스와 정보를 교환해야 할 필요가 있는 여러 상황이 존재할 때, 이러한 통신을 수행하는 두 가지 중요한 방법이 있음

1) **동일한 컴퓨터에서 수행되고 있는 프로세스들 사이**에서 일어남

2) **네트워크에 의해 함께 묶여 있는 서로 다른 컴퓨터 시스템상에서 수행되는 프로세스들 사이**에서 일어남

<br>

통신은 **공유 메모리**를 통해 구현될 수도 있고, **메세지 전달 기법**을 사용해 구현될 수 있음

- 후자의 경우 정보의 패킷들이 운영체제에 의해 프로세스들 사이를 이동

<br>
<br>

**6️⃣ 오류 탐지(error detection)**

운영체제는 모든 가능한 오류를 항상 의식하고 있어야 함

오류는 CPU, 메모리 하드웨어(메모리 오류, 정전 등처럼), 입출력 장치(디스크의 패리티 오류, 네트워크의 접속 실패, 또는 프린터의 종이 부족), 또는 사용자 프로그램(연산의 오버플로 또는 불법적 메모리 위치에 접근 시도)에서 일어날 수 있음

운영체제는 올바르고 일관성 있는 계산을 보장하기 위해 각 유형의 오류에 대해 적당한 조치를 취해야 함

<br>
<br>

**7️⃣ 자원 할당(resource allocation)**

다수의 프로세스나 다수의 작업이 동시에 실행될 때, 그들 각각에 자원을 할당해 주어야 함

운영체제는 여러 가지 다른 종류의 자원을 관리함

👉🏻 CPU, 메모리, 저장장치 등

- 예를 들면, CPU를 최대한 효율적으로 이용하기 위해 운영체제는 CPU 스케줄링 루틴이 CPU의 속도, 반드시 실행해야 할 프로세스들, CPU의 처리 코어의 개수와 다른 요인들을 고려해야 함

<br>
<br>

**8️⃣ 기록 작성(logging)**

어떤 프로그램이 어떤 종류의 컴퓨터 자원을 얼마나 많이 사용하는지를 추적

이와 같은 기록 관리는 회계 또는 단순히 **사용 통계**를 내기 위해 사용됨

👉🏻 컴퓨팅 서비스를 개선하기 위해 시스템을 재구성하고자 하는 시스템 관리자에게 귀한 자료가 될 수 있음

<br>
<br>

**9️⃣ 보호(protection) 와 보안(security)**

다중 사용자 컴퓨터 시스템 또는 네트워크로 연결된 컴퓨터 시스템에 저장된 정보의 소유자는 그 정보의 사용을 통제하길 원함

서로 다른 여러 프로세스가 병행하게 수행될 때, **한 프로세스가 다른 프로세스나 운영체제 자체를 방해해서는 안 됨**

- **보호**는 **시스템 자원에 대한 모든 접근이 통제되도록 보장하는 것을 필요로 함**

  👉🏻 외부로부터의 시스템 보안 또안 중요함


- **보안**은 **각 사용자가 자원에 대한 접근을 원할 때 통상 패스워드를 사용해 시스템에게 자기 자신을 인증하는 것**으로부터 시작됨

  👉🏻 네트워크 어댑터 등과 같은 외부 입출력 장치들을 부적합한 접근 시도로부터 지키고, 침입의 탐지를 위해 모든 접속을 기록하는 것으로 범위를 넓힘

<br>
<br>

## 💭 사용자와 운영체제 인터페이스

사용자가 운영체제와 접촉하는 방식에는 여러 방법이 있음

- 명령어 라인 인터페이스 또는 **명령 인터프리터(command interpreter)** 제공
- 사용자가 그래픽 기반 사용자 인터페이스를 통해 운영체제와 접촉

<br> 
<br>

### 1. 명령 인터프리터

📢  ***운영체제 등에서 입력된 명령어를 읽고 실행하는 컴퓨터 프로그램
<br> ✔️ 사용자가 지정한 명령을 갖고와 수행함***

<br>
모든 운영체제는 명령 인터프리터를 갖고 있는데, 프로세스가 시작하거나 사용자가 로그온될 때 실행되는 프로그램으로서 **셸(Shell)** 이라 부름

- 종류 : `UNIX` , `Linux`(Bourne-shell (bash), C shell 등등), `macOS`(Bourne-again)

명령 인터프리터의 명령어들은 두 가지 방식으로 구현될 수 있음

***1) 명령 인터프리터 자체가 명령을 실행할 코드를 갖는 경우***

- 예를 들면, 한 파일을 삭제하는 명령은 명령 인터프리터가 매개변수를 설정하고, 적절한 시스템 호출을 수행하는 코드의 한 부분으로 이동할 수 있음

<br>

***2) 시스템 프로그램에 의해 대부분의 명령을 구현하는 것***

- 메모리에 적재되어 실행될 파일을 식별하기 위해 명령을 사용함
- 예를 들면, 파일을 삭제하는 다음의 `UNIX` 명령을 실행시키면 `rm` 이라 불리는 파일을 찾아 그 파일을 메모리에 적재하고, 매개변수 `file.txt` 로 수행함

    ```bash
    rm file.txt
    ```

<br>

> *이런 방법으로 프로그래머는 적합한 프로그램 로직을 가진 새로운 파일을 생섬함으로써 시스템에 새로운 명령을 쉽게 추가할 수 있으며, **명령 인터프리터 프로그램**은 **아주 작아질 수 있으며 새로운 명령을 추가하기 위해 변경될 필요가 없음***
>

<br>
<br>

### 2. 그래픽 기반 사용자 인터페이스

📢  ***데스크탑이라는 윈도 메뉴 시스템을 마우스로 사용하는 인터페이스***

<br>

사용자는 마우스를 움직여 마우스 포인터로 프로그램, 파일, 시스템 기능등을 나타내는 화면상의 이미지(아이콘)에 위치시킴

마우스 포인터 위치에 따라, 마우스 버튼을 누름으로써 프로그램을 호출하거나 파일 혹은 디렉토리를 선택할 수도 있고, 명령을 포함한 메뉴를 잡아당길 수도 있음

<br>
<br>

### 3. 터치 스크린 인터페이스

📢  ***모바일 시스템 등에서 이용하는 화면을 터치해 사용하는 인터페이스***

<br>

대부분의 모바일 시스템에는 명령 라인 인터페이스나 마우스 및 키보드를 필요로 하기 때문에 실용적이지 않기 때문에 스마트폰이나 휴대용 태블릿 등은 터치 스크린 인터페이스를 사용함

손가락을 누르거나 스와이프 하는 등 제스처로 상호 작용함

<br>
<br>

### 4. 인터페이스의 선택

컴퓨터를 관리하는 시스템 관리자와, 시스템을 깊게 알고 있는 유저들은 **명령어-라인 인터페이스를 사용함**

명령어-라인 인터페이스는 자체 프로그래밍 기능을 갖추고 있기 때문에 일반적으로 반복 작업을 더 쉽게 만들음

- 예를 들면, 자주 사용되는 작업이 명령어-라인의 여러 절차가 필요로 한다면, 파일로 저장하고 이 파일을 프로그램 실행하듯이 이용할 수 있음

사용자 인터페이스는 시스템마다, 심지어 한 시스템의 사용자마다 다를 수 있음

<br>
<br>

## 💭 시스템 콜

📢  ***운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공함
<br> ✔️ 하드웨어를 직접 접근해야 하는 등 저수준 작업들은 어셈블리 명령을 사용해 작성되어야 하더라도 이런 호출은 `C`, `C++` 언어 기반 함수 형태로 제공됨***

<br>
<br>

### 1. 예제

운영체제가 어떻게 시스템 콜을 사용할 수 있게 만드는지에 대해 살펴보기 전에, 시스템 콜이 어떻게 사용되는지를 설명하는 예를 살펴보자

🤔 **한 파일로부터 데이터를 읽어 다른 파일로 복사하는 간단한 프로그램을 작성하게 되면 ?**

**1️⃣ 명령어를 사용해 두 파일의 이름을 전달**

```bash
cp in.txt out.txt
```

⌨️ `UNIX` `cp` 명령

<br>

**2️⃣ 프로그램이 사용자에게 이름을 요청**

![Untitled 1](https://github.com/SeoYunnn/TIL/assets/120713987/ca869a21-d95c-45c9-8e8a-fe23f6fd3565)
1. 입력 파일 이름을 획득
    1. 화면에 프롬프트를 출력
    2. 입력을 받아들임
2. 출력 파일 이름을 획득
    1. 화면에 프롬프트 출력
    2. 입력을 받아들임
3. 입력 파일 열기
    1. 파일이 존재하지 않을 경우, 비정상적으로 종료
4. 출력 파일 생성
    1. 파일이 존재할 경우, 비정상적으로 종료
5. 루프
    1. 입력 파일로부터 읽어 들임
    2. 출력 파일에 씀
6. 읽기가 실패할때까지, 출력 파일 닫기
7. 화면에 완료 메세지 출력
8. 정상적으로 종료

<br>
<br>

### 2. 응용 프로그램 인터페이스

📢  ***대부분 응용 개발자들은 응용 프로그래밍 인터페이스(Application Programming Interface, API)에 따라 프로그램을 설계함 
<br> ✔️ API**는 **각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함해 응용 프로그래머가 사용 가능한 함수의 집합을 명시***

<br>

응용 프로그래머가 사용 가능한 가장 흔한 세 가지 API는 Windows API, POSIX API(`UNIX` , `Linux` 및 `Mac OS X` 를 포함), Java API

프로그래머는 운영체제가 제공하는 코드의 라이브러리를 통해 API를 활용함

`UNIX` 와 `Linux` 시스템에서 `C` 언어로 작성된 프로그램을 위해서 제공되는 라이브러리는 **libc** 라고 불림

<br>

**🤔 응용 프로그래머는 실제 시스템 콜을 부르는 것보다 API에 따라 프로그래밍 하는 것을 선호할까 ?**

👉🏻 *프로그램의 호환성*

👉🏻 *실제 시스템 콜은 자세한 명세가 필요하고, 가용한 API보다 더 어려움*

- API에 따라 프로그램을 설계하는 응용 프로그래머는 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서건 컴파일되고, 실행된다는 것을 기대할 수 있음 (현실적으로는, 컴퓨터 구조 차이 때문에 쉽지는 않음)

<br>
<br>

### 🧨 표준 API의 예

표준 API의 예로 `UNIX` 와 `Linux` 시스템에서 사용되는 `read()` 함수를 고려해보자

이 함수의 API는 `man` 페이지에서 해당 명령을 호출 해 얻을 수 있음

```bash
man read
```

![Untitled 2](https://github.com/SeoYunnn/TIL/assets/120713987/5551b982-fdd8-40b1-a367-19201a5cce8d)

<br>

`read()` 함수를 사용하는 프로그램은 `unistd.h` 헤더 파일을 포함시켜야 하는데, 이 파일에는 `ssize_t` , `size_t` 데이터 유형이 정의되어 있음

`read()` 함수에게 전달되는 인자는 다음과 같음

- `int fd` : 읽으려는 파일 디스크럽터
- `void *buf` : 데이터를 읽어 들일 버퍼
- `size_t count` : 버퍼로 읽어 들일 수 있는 최대 바이트 수

<br>

읽기가 성공한 경우 읽어 들인 바이트 수가 반환됨

- 반환 값이 `0` → 파일의 끝에 도달
- 반환 값이 `-1` → **오류**가 발생

<br>

시스템 콜을 처리하는 데 있어 중요한 또 다른 요소는 **실행시간 환경(RTE)**
<br> 컴파일러 또는 인터프리터를 포함해 특정 프로그래밍 언어로 작성된 응용 프로그램을 실행하는 데 필요한 전체 소프트웨어 제품군과 라이브러리 또는 로더와 같은 다른 소프트웨어를 함께 가리킴

<br>

**RTE**는 **운영체제가 제공하는 시스템 콜에 대한 연결고리 역할**을 하는 **시스템 콜 인터페이스**를 제공

- **시스템 콜 인터페이스**는 **API 함수의 호출을 가로채 필요한 운영체제 시스템 콜을 부름**
    - 각 시스템 콜에는 번호가 할당되고, 시스템 콜 인터페이스는 이 번호에 따라 색인되는 테이블을 유지함
    - 시스템 콜 인터페이스는 의도하는 시스템 콜을 부르고, 시스템 콜의 상태와 반환 값을 돌려줌

<br>

호출자는 시스템 콜이 어떻게 구현되고 실행 중 무슨 작업을 하는 지 알 필요 없음

API를 준수하고, 시스템 콜의 결과로서 운영체제가 무엇을 할 것인지만 이해하면 됨

✔️ ***따라서 운영체제 인터페이스에 대한 대부분 자세한 내용은 프로그래머로부터 API에 의해 숨겨지고, RTE에 관리됨***

<br>

![Untitled 3](https://github.com/SeoYunnn/TIL/assets/120713987/f82bb2c4-56f9-43c6-9ea3-6fbbb3777cd2)

open() 시스템 콜을 호출했을 때 처리하는 과정 도식화

<br>

운영체제에 매개변수를 전달하기 위해서 세 가지 방법을 사용

***1) 매개변수를 레지스터 내에 전달** (가장 간단한 방법)*

- 매개변수 값을 레지스터에 직접 전달
- **But,** 레지스터 수에 제한이 있어, 많은 매개변수를 다루기 어려울 수 있음

<br>

***2) 메모리 블록 방식***

- 레지스터 수로는 부족한 경우, 매개변수들은 일반적으로 메모리 블록이나 테이블에 저장되고, 해당 블록 주소가 레지스터를 통해 전달됨
- 매개변수의 수나 길이에 더 유연성을 제공

<br>

***3) 스택 방식***

- 프로그램은 매개변수를 스택에 `push` 하고, 운영체제는 스택에서 `pop` 하여 매개변수를 전달
- 이 방식도 유연성이 있고, 많은 매개변수를 처리할 수 있음
- 일부 운영체제는 블록이나 스택 방식을 선호하며, 매개변수의 수나 길이에 제한을 두지 않음

<br>
<br>

### 3. 시스템 콜의 유형

📢 ***시스템 콜은 프로세스 제어, 파일 조작, 장치 조작, 정보 유지 보수 및 통신, 보호 등으로 묶을 수 있음***

![Untitled 4](https://github.com/SeoYunnn/TIL/assets/120713987/70bd5016-2e37-4fef-8356-d0028e897f89)

<br>
<br>

**1️⃣ 프로세스 제어(Process Control)**

실행 중인 프로그램은 수행을 정상적으로 `end()` 또는 `abort()` 로 인해 멈출 수 있어야 함

만약, 프로그램에 문제가 발생해 `trap` 을 유발할 경우, **메모리 덤프가 수행되고 오류 메세지가 생성됨**

- 메모리 덤프 : 현재 프로그램의 메모리 내용을 파일이나 다른 형태로 저장하는 것

  👉🏻 특별한 로그 파일이나 디스크에 기록되고 문제의 원인을 결정하기 위해 디버거에 의해 검사될 수 있음

<br>

GUI 시스템에서는 팝업 윈도가 사용자에게 오류를 알리고 지시를 기다리는데, 일부 시스템에서는 오류가 발생할 경우 특별한 복구 행위를 지시하는 제어 카드를 허용하게 됨

프로그램이 입력에서 오류를 발견하고 비정상적으로 종료하기를 원한다고 하면, 프로그램은 오류 수준을 정의하고자 할 것임

더 심각한 오류는 더 높은 수준의 오류 매개변수로 표시될 수 있음

👉🏻 ***명령 인터프리터나 프로그램은 이 오류 등급을 사용해 다음 행동을 자동으로 결정할 수 있음***

<br>

한 프로그램을 실행하고 있는 프로세스가 다른 프로그램을 **적재(`load()`)** 하고 **실행(`execute()`)** 하기를 원할 수 있는데, 이 기능은 명령 인터프리터가 사용자 명령 또는 마우스의 클릭을 통해 지시된 프로그램을 실행하는 것을 허용함

<br>

🤔 **적재된 프로그램이 종료되었을 때 어디로 제어를 되돌려 줄까 ?**

👉🏻 기존 프로그램이 유실될 지, 보관될 지, 새로운 프로그램과 병행하게 실행을 계속하도록 허용할 지에 따라 달려있음

<br>

새로운 프로그램이 종료되었을 때, 제어가 기존 프로그램으로 되돌아간다면 ***기존 프로그램의 메모리 이미지를 보관해야 함***
<br> 👉🏻 한 프로그램이 다른 프로그램을 호출하는 기법을 만든 셈

두 프로그램이 병행하게 수행
<br> 👉🏻 다중 프로그래밍 될 새로운 프로세스를 생성한 셈

<br>

이러한 특정 목적을 위한 시스템 콜이 존재 (`create process()`)

새로운 프로세스나 여러 프로세스를 생성한다면, 해당 프로세스의 실행을 제어할 수 있어야 함

이러한 제어는 프로세스의 속성을 확인하고 재설정하는 능력을 필요로 함

프로세스 우선순위, 최대 허용 실행 시간 등과 같은 속성을 결정하고 재설정하는데 사용됨

(`get process attributes()` 및 `set process attributes`)

<br>

또한 생성한 프로세스를 종료(`terminate process()`)하려는 경우, 해당 프로세스가 잘못되었거나 더 이상 필요하지 않은 경우에 사용될 수 있음

새로운 프로세스를 생성한 후에는, 실행이 끝나기를 기다려야 할 필요가 있을 수 있음

특정 시간이 지날 때까지 기다릴 수 있으며(`wait time()`) 더 흔하게는 특정 이벤트가 발생할 때까지 기다리는 것임(`wait event()`)

그 후 프로세스는 해당 이벤트가 발생했을 때를 알리기 위해 신호를 보냄(`signal event()`)

<br>

빈번하게 둘 이상의 프로세스들은 데이터를 공유하는데 공유되는 **데이터의 일관성을 보장하기 위해선 운영체제는 종종 프로세스가 공유 데이터를 잠글 수 있는 시스템 콜을 제공함**

잠금이 해제될 때까지 어느 프로세스도 데이터에 접근 **X** (`acquire lock()`, `release lock()`)

<br>

프로세스 제어는 **단일 태스킹 시스템**과 **다중 태스킹 시스템** 두 예시를 사용

- **단일 태스킹 시스템 - Arduino**

  - Arduino는 마이크로 컨트롤러와 다양한 이벤트에 반응하는 입력 센서로 구성된 간단한 HW 플랫폼

  - 응용 프로그램을 작성 하려면 먼저 PC에서 프로그램을 작성한 다음 USB 연결을 통해 컴파일된 프로그램(sketch)을 PC에 Arduino의 플래시 메모리로 업로드

  - 표준 Arduino 플랫폼은 운영체제를 제공하지 않지만 부트 로더로 불리는 작은 소프트웨어가 스케치를 Arduino 메모리의 특정 영역으로 적재

  - 스케치가 적재되면 실행되기 시작하고 반응하도록 프로그램된 이벤트를 기다림

    - 예를 들면, Arduino 온도 센서가 측정 온도의 특정 임계값을 초과했을 때, 팬의 모터를 작동시키게 만들 수 있음

<br>

![Untitled 6](https://github.com/SeoYunnn/TIL/assets/120713987/0b9b3be7-8b6b-44d7-8009-c721ff14fcf3)

> *Arduino는 **한 순간에 하나의 스케치만 메모리에 존재할 수 있으므로, 단일 태스킹 시스템으로 간주**됨
다른 스케치가 적재되면 기존 스케치를 대체하고, 하드웨어 입력 센서 이외의 UI를 제공하지 않음*
>

<br>

- **다중 태스킹 시스템 - FreeBSD(UNIX로부터 비롯됨)**

  - 사용자가 시스템에 로그인할 때 사용자가 선택한 셸이 수행되어 명령을 기다렸다가 사용자가 요청한 프로그램을 수행

  - **But,** FreeBSD는 다중 태스킹 시스템이기 때문에 명령 인터프리터는 다른 프로그램이 실행되는 동안 수행을 계속할 수 있음

  - 새로운 프로세스를 시작하기 위해 셸은 `fork()` 시스템 콜을 실행

  - 선택된 프로그램이 `exec()` 시스템 콜을 통해 메모리에 적재되고, 프로그램이 수행됨

  - 명령이 내려진 방법에 따라 셸은 프로세스가 종료하기를 기다리거나 “백그라운드” 에서 프로세스를 수행

  - 프로세스가 끝나면 종료하기 위해 `exit()` 시스템 콜을 수행해 호출한 프로세스에게 상태 코드 0을 돌려주거나 0이 아닌 오류 코드를 돌려줌

![Untitled 7](https://github.com/SeoYunnn/TIL/assets/120713987/25be5d64-5117-4246-bfa6-c4d3b9f01f6f)

<br>
<br>

**2️⃣ 파일 관리(File Management)**

파일을 생성(`create()`)하고 삭제(`delete()`)할 수 있어야 함

파일이 생성되면 열고(`open()`), 읽고(`read()`), 쓰고(`write()`), 위치 변경(`re-position`), 되감기(`rewind()`) 할 수 있음

파일을 더 이상 사용하지 않음을 나타내는 파일 닫기(`close()`)도 필요

<br>

파일 시스템이 파일을 조직하기 위해 디렉토리 구조를 가진다면, 파일이나 디렉토리에 대해 여러 속성의 값을 결정할 수 있어야 하고 필요에 의해 재설정(`reset`) 할 수 있어야 함

- 파일 속성은 파일 이름, 파일 유형, 보호 코드, 회계 정보 등을 포함

<br>

이러한 기능을 하기 위해서는 최소한 파일 속성 획득(`get file attribute()`)과 파일 속성 설정(`set file attribute()`)의 두 시스템 콜 필요

몇몇 운영체제는 파일 이동(`move()`)과 복사(`copy()`) 등 훨씬 더 많은 시스템 콜을 제공함

<br>

> *일부 시스템들은 코드와 다른 시스템 콜을 이용해 동일한 작업을 수행하는 API를 제공할 수도 있고 일부 시스템은 단순히 동일한 작업을 수행하는 시스템 프로그램을 제공하기도 함*
>

<br>
<br>

**3️⃣ 장치 관리(Device Management)**

프로세스는 작업을 계속 수행하기 위해 추가 자원이 필요할 경우가 있음

- 주 기억장치
- 디스크 드라이브
- 파일의 접근

<br>

자원들을 사용할 수 있다면, 자원이 주어지고 제어가 사용자 프로그램으로 복귀될 수 있지만 그렇지 않다면 자원이 사용 가능할때까지 기다려야 함

운영체제의 의해 제어되는 다양한 자원들은 장치로 간주될 수 있는데, 일부는 물리장치(디스크 드라이브 등)이고 다른 장치들은 추상적 혹은 가상적 장치(파일)로 존재할 수 있음

다수의 사용자가 동시에 사용하는 시스템은 독점적 장치 사용을 보장받기 위해 장치를 요청(`request()`)

장치의 사용이 끝난다면, 반드시 방출(`release()`) 필요

<br>

입출력 장치와 파일 간에는 유사성이 매우 많기에 `UNIX` 를 포함한 많은 운영체제가 이들을 통합된 **파일-장치 구조**로 결합

시스템 콜이 파일과 장치에 대해 사용되는데, 때로 입출력 장치들은 특별한 파일 이름, 디렉토리 배치 또는 파일 속성으로 식별됨

<br>
<br>

**4️⃣ 정보 유지 관리(Information Maintenanace)**

시스템 콜은 단순히 사용자 프로그램과 운영체제 간 정보 전달을 위해 존재

- 시스템 대부분은 현재 시간(`time()`), 날짜(`date()`) 시스템 콜을 갖고 있음
- 다른 시스템 콜은 운영체제의 버전 번호, 자유 메모리 또는 자유 디스크 공간 등과 같은 시스템에 관한 정보를 알려줌

<br>

다른 시스템 콜 집합은 프로그램 디버깅에 도움이 많이 되는데, 메모리를 덤프하기 위한 시스템 콜을 제공함

많은 운영체제는 프로그램의 시간 프로파일(time profile)을 제공함

- 프로그램의 특정 위치, 수행한 시간의 양 을 나타냄
- 추적 설비나 정규 타이머 인터럽트 필요
- 타이머 인터럽트가 발생할 때마다, 프로그램 카운터 값이 기록되는데 빈번하게 일어난다면 통계적 그림도 얻을 수 있음

<br>

운영체제는 현재 운영되고 있는 모든 프로세스에 대한 정보를 갖고 있는데, 이런 정보에 접근하기 위한 시스템 콜이 존재

프로세스 정보 획득하고 설정

- `get process attributes()`
- `set process attributes()`

<br>
<br>

**5️⃣ 통신(Communication)**

통신 모델은 두 가지 모델 존재

<br>

***1) 메세지 전달***

**통신하는 두 프로세스가 정보를 교환하기 위해 서로 메세지를 주고 받음**

- 메세지는 두 프로세스 간에 직접 교환되거나, 우편함을 통해 간접적으로 교환됨

<br>

상대 통신자(communicator)가 동일한 CPU에 있는 프로세스 or 통신 네트워크에 의해 연결된 다른 컴퓨터에 있는 프로세스 👉🏻 **이름을 반드시 알고 있어야 함**

<br>

네트워크의 각 컴퓨터는 호스트 이름을 가지며, 각 프로세스는 프로세스 이름을 갖고 이 이름은 식별자로 변환돼 운영체제가 프로세스를 가르키는 데에 사용됨

- `get hostid()`, `get processid()`

<br>

식별자는 그 후, 시스템 통신 모델에 따라 `open`, `close` 호출에 전달되거나 특정 `open connection()` 과 `close connoection()` 시스템 콜에 전달됨

수신 프로세스는 일반적으로 통신이 이루어지도록 허용하기 위해 `accept connection()` 호출을 수행해야 함

연결을 받아들일 프로세스들의 대부분은 특수 목적의 데몬으로 그러한 목적을 위해 제공된 시스템 프로그램들

연결을 위해 대기(`wait for connection()`) 호출을 수행하고 연결이 이루어지면 깨어나게 됨

통신의 송신자인 클라이언트와 수신 데몬인 서버는 `read message()` 및 `write message()` 시스템 콜을 사용해 메세지를 교환하고 끝내 `close connection()` 호출로 통신을 종료

<br>
<br>

***2) 공유 메모리***

프로세스는 다른 프로세스가 소유한 메모리 영역에 대한 접근을 위해 `shared memory create()` 와 `shared memory attach()` 시스템 콜을 사용

보통 운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는 것을 막으려고 함

**But,** 공유 메모리는 **두 개 이상의 프로세스가 이 제한을 해제하기로 합의할 때 사용됨**

그 후, 공유된 영역에서 데이터를 읽고 쓰면서 정보를 교환할 수 있음

데이터의 형식은 프로세스에 의해 결정되며 운영체제의 통제를 받지 않음

또한 프로세스는 동시에 동일한 위치에 쓰지 않도록 보장하는 책임이 있음

<br>

이러한 두 모델은 운영체제에서 흔히 사용되며, 대부분 시스템에서는 두 가지 모두를 구현함

- ***메세지 전달***
    - 충돌을 피할 필요가 없기 때문에 소량의 데이터를 교환하는 데 유용
    - 컴퓨터 간 통신에 대한 공유 메모리보다 구현하기 쉬움

- ***공유 메모리***
    - 컴퓨터 내에서 진행되는 경우 메모리 전송 속도에서 수행될 수 있기 때문에 최대 속도와 편의성 제공
    - **But,** 메모리를 공유하는 프로세스 간 보호, 동기화 부분에서 문제가 존재

<br>
<br>

**6️⃣ 보호(Protection)**

컴퓨터 시스템이 제공하는 자원에 대한 접근을 제어하기 위한 기법을 지원함

역사적으로, 보호는 다수의 사용자가 있는 다중 프로그램 컴퓨터 시스템에서만 고려되었음

**But,** 네트워킹과 인터넷의 등장으로 서버에서 휴대용 컴퓨터까지 모든 컴퓨터 시스템에서 보호를 고려 할 필요함

보호를 지원하는 시스템 콜 존재

- `set permission()`, `get permission()`
    - 파일의 디스크와 같은 자원의 허가 권한을 설정하는 데에 이용
- `allow user()`, `deny user()`
    - 특정 사용자가 지정된 자원에 대한 접근이 허가 혹은 불허되었는지를 명시

<br>
<br>

## 💭 시스템 서비스

현대 시스템의 또 다른 면은 시스템 서비스의 집합

논리적 컴퓨터 계층 구조를 나타내는 그림을 보면, HW, 운영체제, 시스템 서비스, 응용 프로그램 순

![Untitled 8](https://github.com/SeoYunnn/TIL/assets/120713987/7fc0643a-ea37-4a05-a080-894abde022ad)

<br>

**시스템 서비스** 또는 **시스템 유틸리티(system utility)** 로 알려진 이 서비스들은 프로그램 개발 및 실행에 편리한 환경을 제공하는데, 이 중 일부는 시스템 호출에 대한 UI에 불과하며 다른 것들은 상당히 복잡할 수 있음

이들은 다음과 같은 몇 가지 범주로 분류 가능

<br>
<br>

**1️⃣ 파일 관리**

- 파일과 디렉토리를 생성, 삭제, 복사, 리네임, 인쇄, 열거, 일반적 조작

<br>
<br>

**2️⃣ 상태 정보**

- 일부 프로그램은 시스템에게 날짜, 시간, 사용 가능 메모리, 디스크 공간, 사용자 수 등과 같은 상태 정보 요청
- 다른 프로그램들은 더 복잡하고 세부적인 성능, 로깅 및 디버깅 정보를 제공
- 일반적으로 이런 프로그램들은 출력을 형식화 하고 터미널이나 다른 출력 장치 또는 파일에 출력하거나 GUI 창에 표시
- 일부 시스템은 구성 정보를 저장하고 검색할 수 있는 레지스트리 기능을 지원하기도 함

<br>
<br>

**3️⃣ 파일 변경**

- 디스크나 다른 저장 장치에 저장된 파일 내용을 생성하고 변경하기 위해 다수의 문장 편집기를 사용할 수 있음
- 파일의 내용을 검색하거나 변환하기 위해 특수 명령어가 제공되기도 함

<br>
<br>

**4️⃣ 프로그래밍 언어 지원**

- 프로그래밍 언어들에 대한 컴파일러, 어셈블러, 디버거 및 해석기가 종종 운영체제와 함께 사용자에게 제공되거나 별도로 다운로드 받을 수 있음

<br>
<br>

**5️⃣ 프로그램 적재와 수행**

- 프로그램이 어셈블되거나 컴파일된 후, 수행되려면 반드시 메모리에 적재되어야 하는데 시스템은 절대 로더, 재배치 가능 로더, 링키지 에디터와 중첩 로더등을 제공할 수 있음
- 고급어나 기계어를 위한 디버깅 시스템도 필요

<br>
<br>

**6️⃣ 통신**

- 프로세스, 사용자, 다른 컴퓨터 시스템들 사이에 가상 접속을 위한 기법 제공
- 사용자가 다른 사용자 화면으로 메세지를 전송하거나 웹 페이지를 읽거나, 전자 우편 메세지를 보내거나 원거리에서 로그인을 하거나 한 기계에서 다른 기계로 파일을 전송할 수 있음

<br>
<br>

**7️⃣ 백그라운드 서비스**

- 모든 범용 시스템은 부팅 시점에 특정 시스템 프로그램을 시작시킬 수 있는 방법을 갖고 있음
- 이런 프로세스 중 일부는 작업을 완료 후 종료하지만, 일부는 시스템이 중지될 때까지 계속 실행됨
- **계속해서 실행되는 프로그램 프로세스를 서비스, 서브시스템, 또는 데몬**이라고 함
    - 지정된 스케줄에 따라 프로세스를 시작시키는 프로세스 스케줄러, 시스템 오류 모니터링 서비스, 출력 서버 등이 있음
- 일반적인 시스템에는 수십 개의 데몬이 존재
- 또한 중요한 활동을 커널 컨텍스트가 아닌, 사용자 컨텍스트에서 실행해야 하는 경우, 데몬을 이용해 작업을 수행할 수 있음

<br>
<br>

> *운영체제 대부분은 시스템 프로그램과 함께 **일반적인 문제점을 해결하거나, 일반적인 연산을 수행하는 데 유용한 프로그램들도 제공함**
이러한 응용 프로그램에는 웹브라우저, 워드 프로세서와 텍스트 포맷터, 스프레드 시트, 데이터베이스 시스템, 컴파일러, 도면 제작, 통계분석 패키지, 게임 등이 포함*
>

<br>
<br>

## 💭 링커와 로더

프로그램은 디스크에 이진 실행 파일로 존재하는데, CPU에서 실행하기 위해선 프로그램을 메모리로 가져와 프로세스 형태로 배치되어야 함

소스 파일은 임의의 물리 메모리 위치에 적재되도록 설계된 오브젝트 파일로 컴파일됨

👉🏻 ***재배치 가능 오브젝트 파일***

<br>

- **링커**는 **재배치 가능 오브젝트 파일을 하나의 이진 실행 파일로 결합**

    링킹 단계에서 `C` 또는 수학 라이브러리와 같은 다른 오브젝트 파일 또는 라이브러리도 포함될 수 있음

- **로더**는 **이진 실행 파일을 메모리에 적재하는 데 사용**되며, CPU 코어에서 실행할 수 있는 상태가 됨

링킹 및 로딩과 관련된 활동은 **재배치**로, 프로그램 부분에 최종 주소를 할당하고 프로그램 코드와 데이터를 해당 주소와 일치하도록 조정해 프로그램이 실행될 때 코드가 라이브러리 함수를 호출하고 변수에 접근할 수 있게 함

<br>

그림처럼 로더를 실행하려면, 명령어 라인에 실행 파일의 이름을 입력하기만 하면 된다는 것을 알 수 있음

![Untitled 9](https://github.com/SeoYunnn/TIL/assets/120713987/2d958333-5949-415b-86ab-5f5fee9a3707)

<br>


`UNIX` 시스템의 명령어 라인에 프로그램을 입력하면 셀은 먼저 `fork()` 시스템 콜을 사용해, 새 프로세스를 생성함

`exec()` 시스템 콜로 로더를 호출 후, 실행 파일 이름을 전달

새로 생성된 프로세스의 주소 공간을 사용해, 지정된 프로그램을 메모리에 적재

GUI 인터페이스를 사용할 경우 실행 파일과 연관된 아이콘을 두 번 클릭하면 유사한 매커니즘을 사용해, 로더 호출

<br>

시스템 대부분에서는 프로그램이 적재될 때, 라이브러리를 동적으로 링크할 수 있게 함

`Window` 는 **동적 링킹 라이브러리(Dynamically Linked Library, DLL)** 를 지원

실행 파일에서 사용 되지 않을 수 있는 라이브러리를 링크하고 로드 하지 않아도 됨

대신, 라이브러리는 조건부로 링크 되며 프로그램 실행 시간에 필요한 경우 적재됨

오브젝트 파일 및 실행 파일은 표준화된 형식을 지님

이 표준 형식은 컴파일된 기계 코드 및 프로그램에서 참조되는 함수 및 변수에 대한 metadata 를 포함하는 심볼 테이블이 포함되어 있음

<br>

`UNIX` 및 `Linux` 시스템 경우 이 표준 형식을 **ELF(Executable and Linkable Format)** 라 함

재배치 가능 파일과 실행 파일 각각을 위한 별도의 ELF 형식이 사용되는데, 실행 파일의 ELF 파일에 있는 정보 중 하나는 프로그램의 시작점

프로그램이 실행될 때 실행되는 첫 번째 명령의 주소를 포함

<br>
<br>

### 🧨 ELF 형식

`Linux` 는 ELF 파일을 식별하고, 분석하기 위한 다양한 명령들을 제공함

예를 들어, `file` 명령은 파일 유형을 결정함

`main.o` 가 오브젝트 파일이고, `main` 이 실행 파일인 경우 명령

```bash
file main.o
```

<br>

는 `main.o` 가 ELF 재배치 가능 파일이라고 보고하며, 명령

```bash
file main
```

은 `main` 이 ELF 실행 파일이라고 보고함

ELF 파일은 여러 섹션으로 구분되며, `readelf` 명령을 사용해 분석할 수 있음

<br>
<br>

## 💭 응용 프로그램이 운영체제마다 다른 이유


한 운영체제에서 컴파일된 응용 프로그램은 다른 운영체제에서 실행할 수 없음

각 운영체제는 독특한 시스템 콜 집합을 제공하는데, 시스템 콜은 응용 프로그램이 사용할 수 있도록 운영체제가 제공하는 서비스 집합의 일부임

심지어 시스템 콜이 통일되어 있더라도, 다른 장벽으로 인해 다른 운영체제에서 응용 프로그램을 실행하기 어렵게 만들 것

**But,** 여러 운영체제를 사용해 본 경험이 있다면 동일한 응용 프로그램을 여러 운영체제에서 사용한 적이 있을 것임

<br>

**🤔 어떻게 가능한 일일까 ?**

<br>
<br>

### 1. 운영체제마다 인터프리터가 제공되는 인터프리터 언어(Python, Ruby)로 작성

특정 언어로 작성된 인터프리터를 이용해 응용 프로그램을 여러 운영체제에서 실행할 수 있음

인터프리터는 소스 프로그램의 각 라인을 읽고, 상응하는 기계어 명령을 실행하고 해당 운영체제의 시스템 콜을 호출함

기계어 코드로 구성된 응용 프로그램에 비해 성능이 떨어지고, 인터프리터는 각 운영체제의 기능의 일부만 제공하므로 관련 응용 프로그램의 기능도 제한될 수 있음

<br>
<br>

### 2. 가상 머신을 지닌 언어로 작성

응용 프로그램은 실행 중인 응용 프로그램을 포함하고 있는 가상 머신을 가진 언어로 작성될 수 있음

- 가상머신은 RTE의 일부

<br>

예시로는 `Java` 가 있음

`Java` 는 `Java` 애플리케이션을 `Java` 가상 머신에 로드하는 로더, 바이트 코드 검증기 및 기타 구성 요소를 포함한 RTE를 갖추고 있음

이 RTE는 많은 운영 체제로 이식되거나 개발되어 왔으며, 메인프레임부터 스마트폰까지 다양한 운영 체제에서 동작할 수 있음

**But,** 인터프리터와 유사한 단점을 지니고 있음

<br>
<br>

### 3. 표준 언어 또는 API 사용

응용 프로그램 개발자는 컴파일러가 기기 및 운영체제에 특화된 언어로 이진파일을 생성하는 표준 언어 또는 API를 사용할 수 있음

응용 프로그램은 실행될 각 운영체제에 이식되어야 함

이식 작업은 상당히 시간이 많이 소요되며, 각 응용 프로그램의 새 버전마다 수행되어야 하고, 테스트와 디버깅이 필요함

<br>

세 가지 접근 방식은 다양한 운영체제에서 실행 가능한 응용 프로그램을 개발하는 간단한 해결책을 제공하는 것처럼 보임

**But,** 응용 프로그램의 이동성 부족은 여전히 크로스 플랫폼 응용 프로그램을 개발하는 것을 어렵게 만드는 여러 원인이 존재함

운영체제와 함께 제공되는 라이브러리는 GUI 인터페이스와 같은 기능을 제공하기 위한 API를 포함하며, 특정 API(ex: IOS)를 호출하도록 설계된 응용 프로그램은 해당 API(ex: Android)를 제공하지 않는 운영체제에서는 작동하지 않음

또한 시스템의 낮은 수준에서도 다른 어려운 점이 존재함

- 각 운영체제는 응용 프로그램의 헤더, 명령어 및 변수의 배치를 강제하는 이진 형식을 가짐, 이런 구성 요소들은 실행 파일 내에서 명시된 구조에 특정 위치에 있어야 운영체제가 파일을 열고 적재해 올바르게 실행할 수 있음
- CPU는 다양한 명령어 집합을 가지며 해당 명령어가 포함된 응용 프로그램만 올바르게 실행 가능
- 운영체제는 응용 프로그램이 파일 생성과 네트워크 연결 개방과 같은 다양한 활동을 요청하는 데 사용되는 시스템 콜을 제공함, 이런 시스템 콜은 피연산자 및 순서, 응용 프로그램이 시스템 콜을 호출하는 방법, 시스템 콜 번호, 의미 및 반환 결과를 포함해 여러 측면에서 운영체제마다 다름

<br>

이러한 구조적 차이점을 완전히 해결하지는 못 했지만, 해결하는 데 도움이 되는 몇 가지 방법이 있음

<br>

***1) ELF 형식의 실행 파일***

- `Linux` , `UNIX` 시스템에서 ELF 형식을 채택해 실행 파일의 공통 표준을 제공
- **But,** ELF 형식은 특정 컴퓨터 아키텍처에 연관되어 있지 않으므로 **다른 하드웨어 플랫폼 간의 완벽한 호환성을 보장하지는 않음**

<br>

***2) 응용 프로그램 이진 인터페이스(ABI)***

- ABI는 아키텍처 수준에서 다양한 구성 요소가 특정 운영체제와 아키텍처에서 어떻게 상호 작용할 지를 정의함
- 주소 길이, 시스템 콜에 매개변수 전달 방법, 런타임 스택 구성, 시스템 라이브러리의 이진 형식 및 데이터 유형의 크기 등의 하위 수준의 세부 정보를 명시함
- ABI를 따르는 이진 실행 파일은 해당 ABI를 지원하는 다양한 시스템에서 실행될 수 있지만, **특정 운영체제와 아키텍처에 종속되어 있기 때문에 플랫폼 간 호환성을 거의 제공하지 않음**

<br>
<br>

> *요약하면, 이런 모든 차이점은 특정 CPU 유형의 특정 운영체제에서 인터프리터, RTE 또는 이진 실행 파일을 작성하고 컴파일하지 않으면 응용 프로그램이 실행되지 않는다는 것을 의미
<br>✔️  **각 환경에 최적화된 실행 파일이나 런타임 환경이 필요하며, 이를 통해 응용 프로그램이 특정 운영체제 및 CPU에서 올바르게 동작할 수 있음***
>

<br>
<br>

## 💭 운영체제 설계 및 구현

운영체제를 설계하고 구현할 때 직면하는 문제점을 논의

물론, 설계 문제점에 대한 완전한 해결책은 없지만 성공적인 접근 방법들은 있음

<br>
<br>

### 1. 설계 목표

시스템을 설계하는 데에 있어 **첫 번째 문제점**은 **시스템의 목표와 명세를 정의**하는 일

시스템 설계는 최상위 수준에서는 하드웨어와 시스템 유형(일괄처리, 시분할, 단일 사용자, 다중 사용자, 분산, 실시간 혹은 범용)의 선택에 의해 영향을 받을 것임

👉🏻 이 설계 수준을 넘어서면 **요구 사항을 명시하는 것이 훨씬 어려워짐**

<br>

**But,** 요구 사항은 기본적으로 **사용자 목적**과 **시스템 목적** 두 가지 그룹으로 나뉨

- **사용자 목표**
    - 사용자는 일반적으로 시스템이 편리하고 사용하기 쉽고 신뢰성 있으며 안전하고 빠르기를 원함
    - **But,** 이러한 사용자 중심 명세는 시스템 설계에 있어, 어떻게 이를 달성할지에 대한 일반적 합의 사항이 없기 때문에 유용하지 않음
- **시스템 목표**
    - 시스템을 설계, 구현, 유지보수 및 운영해야 하는 개발자들은 시스템이 설계하기 쉽고, 구현하기 쉽고, 유지보수 하기 쉬우며 유연하고 신뢰성 있고 오류가 없으며 효율성을 가져야 한다고 하는 유사한 요구사항을 정의할 수 있음
    - 다시 말해, 이런 요구 사항은 **모호하며 다양한 방식으로 해석**될 수 있음

<br>

>  *요약하면, **운영체제의 요구사항을 정의하는 문제엔 고유한 해결책이 존재하지 않음**,각종 다른 환경에 대한 다양한 솔루션으로 이어지는 다른 요구 사항들이 다양한 시스템 범위에서 존재함을 보여줌
운영체제의 명세와 설계는 매우 창조적인 일이며 운영체제에 적용 가능한 일반적 원칙들이 존재함*
>

<br>
<br>

### 2. 기법과 정책

한 가지 중요한 원칙은 **기법으로부터 정책을 분리**하는 것

- 기법 : 어떤 일을 ***어떻게*** 할 것인가
- 정책 : ***무엇을*** 할 것인가

<br>

정책과 기법의 분리는 **유연성을 위해 아주 중요함**

정책은 장소 또는 시간에 따라 변할 가능성이 높은데, 최악의 경우 정책 변경마다 기본 기법을 변경해야 할 수 있음

그렇게 되면 정책의 변경은 시스템 일부 매개변수만을 재정의하도록 요구됨

<br>

예를 들어, 한 유형의 프로그램이 다른 유형의 프로그램보다 높은 우선순위를 갖도록 하는 기법을 고려해보자

- 기법이 정책으로부터 적절하게 분리되면, I/O 중심 프로그램이 CPU 중심 프로그램 보다 우선순위를 갖도록 지원하는 정책이나 정반대 정책을 지원하는 데 사용될 수 있음

<br>

> *정책 결정은 모든 자원 할당 문제에 있어 중요하며, 자원의 할당 여부를 결정할 필요가 있을 때마다 정책 결정을 해야 함
✔️ **무엇(what)이 아닌 어떻게(how)일때마다, 반드시 결정되어어야 하는 것은 “기법”***
>

<br>
<br>

### 3. 구현

운영체제의 설계가 완료되면 구현되어야 함

운영체제는 많은 사람에 의해 오랫동안 개발된 많은 프로그램의 집합체이기 때문에 구현 방법에 대해 일반적 언급은 어려움

초기 운영체제는 어셈블리 언어로 작성되었지만 이제는 대부분 `C` 또는 `C++` 와 같은 고급 언어로 작성되며 극히 일부의 시스템이 어셈블리 언어로 작성됨

- 커널의 최하위 레벨은 어셈블리 언어 및 `C` 로 작성될 수 있음
- 상위 레벨 루틴은 `C` 및 `C++` 로 작성될 수 있음
- 시스템 라이브러리는 `C++` 또는 상위 레벨 언어로 작성될 수 있음

<br>

`Android` 는 이에 좋은 예시를 제공

- 커널은 대부분 `C` 로 작성되어 있으며 어셈블리어도 일부 사용
- 대부분 안드로이드 시스템 라이브러리는 `C` 또는 `C++` 로 작성되며, 시스템 개발자 인터페이스를 제공하는 응용 프로그램 프레임워크는 주로 `Java` 로 작성되었음

<br>

운영체제를 구현하기 위해 고급 언어나 최소한 시스템 구현 언어를 사용함으로써 생기는 **장점**은 응용 프로그램과 해당 언어를 사용할 때 얻는 이점과 동일

1) **코드를 더 빨리 작성할 수 있으며 더 적은 용량으로 더 쉽게 이해하고 디버그** 할 수 있음

2) 컴파일러 기술의 개선은 전체 운영체제의 생성된 코드를 단순한 재 컴파일에 의해 **전체 운영체제를 위해 생성된 코드를 향상**

3) 고수준 언어로 작성된 운영체제는 **다른 하드웨어로 쉽게 이식 가능**

- 작은 임베디드 장치, `Intel x86` 시스템 및 폰 태블릿에서 실행되는 ARM 칩과 같이 여러 다양한 하드웨어 시스템에서 실행되도록 의도된 운영체제의 경우 중요❗️

<br>

고수준 언어로 구현하는 것에 대해 **단점**도 존재

**속도 감소**와 **저장장치가 많이 소요됨**(현재 시스템에서는 큰 문제는 **X**)
전문적 어셈블리어 프로그래머는 효율적인 작은 루틴을 작성할 수는 있지만 대형 프로그램의 경우 현대의 컴파일러는 복잡한 분석을 수행하고, 탁월한 코드를 생성하는 정교한 최적화를 적용할 수 있음

<br>

> *다른 시스템에서처럼 운영체제에서 주요 성능 향상은 **우수한 어셈블리어 코드보다는 좋은 자료구조와 알고리즘의 결과로 나타날 가능성이 높음**
또한, 운영체제가 크더라도 높은 성능에 중요한 코드는 매우 적음
✔️ **인터럽트 핸들러, I/O 관리자, 메모리 관리자 및 CPU 스케줄러가 가장 중요한 루틴***
>

<br>
<br>

## 💭 운영체제 구조

현대의 운영체제와 같이 크고 복잡한 시스템은 적절하게 동작하고 쉽게 변경될 수 있으려면 신중히 제작되어야 함

일반적 접근 방법은 한 개의 일관된 시스템보다는 **태스크를 작은 구성 요소로 분할하는 것**

<br>
<br>

### 1. 모놀리식 구조

운영체제를 구성하는 가장 간단한 구조는 **구조가 X**

👉🏻 커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진 파일에 넣는 것

👉🏻 ***”모놀리식 구조”***

<br>

[ 제한적 구조를 가진 운영체제의 예는 최초의 `UNIX` 운영체제 ]

![Untitled 10](https://github.com/SeoYunnn/TIL/assets/120713987/b18c0d81-5db5-4db1-8fc3-ab96778412cc)

**커널**과 **시스템 프로그램** 두 가지로 구성

- 커널은 여러 가지 인터페이스와 장치 드라이버로 다시 분리

<br>

시스템 콜 인터페이스 아래와 물리적 하드웨어 위의 모든 것이 커널

커널은 시스템 콜을 통해 파일 시스템, CPU 스케줄링, 메모리 관리 그리고 다른 운영체제 기능을 제공

👉🏻 하나의 단일 주소 공간에 결합하기에는 엄청난 양의 기능

<br>
<br>

[ `UNIX` 에 기반을 둔 `Linux` 운영체제 ]

![Untitled 11](https://github.com/SeoYunnn/TIL/assets/120713987/7c197a04-0072-4db4-9be0-22ba4901f456)

응용 프로그램은 일반적으로 커널에 대한 시스템 콜 인터페이스와 통신할 때 glibc 표준 `C` 라이브러리를 사용

<br>

`Linux` 커널은 모놀리식이지만 런타임 중에 커널을 수정할 수 있는 모듈식 설계를 갖추고 있음

모놀리식 커널의 표면적 간결함에도 불구하고, 이를 **구현하고 확장하는 것은 어려움**

<br>

**But,** 모놀리식 커널은 성능 면에서 뚜렷한 이점이 있음

**시스템 콜 인터페이스에서는 오버헤드가 거의 없고, 커널 내에서의 통신 속도가 빠름**

👉🏻 모놀리식 커널의 단점에도 불구하고, `UNIX`, `Linux` 및 `Windows` 운영체제에서 이 구조를 여전히 볼 수 있는 이유

<br>
<br>

### 2. 계층적 접근

모놀리식 접근법은 종종 **밀접하게 결합된 시스템**으로 불림

-> 시스템의 한 부분을 변경하면 다른 부분에 광범위한 영향을 줄 수 있음

<br>

반면 **느슨하게 결합된 시스템**을 설계할 수 있음

이러한 시스템은 특정 기능 및 한정된 기능을 가진 개별적이며 작은 구성 요소로 나뉘는데, 이 모든 구성 요소가 합쳐져 **커널을 구성**

<br>

이 모듈 방식의 장점은 **한 구성 요소의 변경이 해당 구성 요소에만 영향을 미치고, 다른 구성 요소에는 영향을 미치지 않기 때문에 시스템 구현자가 내부 동작을 더 자유롭게 만들고 변경**할 수 있다는 것

![Untitled 12](https://github.com/SeoYunnn/TIL/assets/120713987/72fe89ae-2ae1-4ef9-9592-f6261f1baba2)

<br>

시스템은 다양한 방식으로 모듈화 될 수 있는데, 그 중 한 가지 방식이 **계층적 접근 방식**

이 방식에는 운영체제가 여러 개의 층으로 나뉘어짐

- `layer 0` : 하드웨어
- `layer N` : UI

<br>

계층적 접근 방식의 주된 장점은 **구현과 디버깅의 간단함**에 있음

층들은 자신의 하위층들의 서비스와 기능들만을 사용하도록 선택됨 👉🏻 **시스템의 검증과 디버깅 작업 단순화**

<br>

첫 번째 층은 하드웨어만을 사용해 구현하기 때문에, 나머지 시스템에 아무런 신경을 쓰지 않고 디버깅할 수 있음

첫 번째 층의 디버깅이 끝나면, 두 번째 층을 디버깅하는 동안 정확하게 동작한다고 가정될 수 있으며 이런 과정이 반복됨

만약, 어느 층의 디버깅 중 오류가 발생하면 **그 하위의 층은 이미 디버깅되었기 때문에 원인은 반드시 그 해당 층에 존재**함

***✔️ 따라서 시스템을 계층으로 나누면 설계나 구현이 간단해짐***

<br>

계층화된 시스템은 컴퓨터 네트워크(ex: TCP/IP) 및 웹 응용 프로그램에서 성공적으로 사용됐음

그럼에도 불구하고 순수한 계층 접근 방식을 사용하는 운영체제는 **비교적 적음**

👉🏻 **각 계층의 기능을 적절히 정의해야 하는 문제와 관련**이 있음

👉🏻 전반적 성능은 운영체제 서비스를 얻기 위해 사용자 프로그램이 여러 계층을 통과해야 하는 오버헤드로 인해 열악

<br>

**But,** 현대 운영체제에서는 일부 계층화가 흔함

일반적으로 이런 시스템은 더 많은 기능을 갖는 적은 수의 계층을 갖고 있으며, 코드의 모듈화 장점 대부분을 제공하면서 계층 정의 및 상호 작용의 문제를 피함

<br>
<br>

### 3. 마이크로 커널

초기 `UNIX` 가 모놀리식 구조를 가진다는 것을 알았음

`UNIX` 가 확장됨에 따라 커널은 커지고 관리하기 힘들어졌음

중반에 `Mach` 라는 운영체제를 개발해 커널을 모듈화하는 데 성공했음

이 방법은 커널에서 모든 중요치 않은 구성 요소를 제거하고 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현해 운영체제를 구성하는 방식 👉🏻 결과적으로 **더 작은 커널이 생성**됨

어떤 서비스가 커널에 남아 있어야 하고 사용자 공간에 구현되어야 하는지에 대한 의견이 일치하지는 않음

<br>

**But,** 일반적으로 마이크로커널은 통신 설비 외에 추가로 최소한의 프로세스와 메모리 관리를 제공함

![Untitled 13](https://github.com/SeoYunnn/TIL/assets/120713987/9018d75c-f6a6-47d2-a60f-a376bc5ac38b)

<br>

📢  ***마이크로커널 접근 방식의 이점 중 하나는 운영체제를 확장하기가 더 쉬워진다는 점
커널을 수정해야 할 때, 변경사항은 더 적을 가능성이 있으며 마이크로커널은 더 작은 커널이기 때문에, 더 적은 변경이 필요
<br> ✔️ 생성된 운영체제는 하드웨어 디자인에서 다른 디자인으로 쉽게 이식할 수 있음***

<br>

마이크로커널 운영체제의 가장 잘 알려진 예 중 하나는 `macOS` 및 `iOS` 운영체제의 커널 구성 요소인 `Darwin`

- 두 개의 커널로 구성되어 있음
- 그 중 하나는 `Mach` 마이크로 커널

추가적으로는, `QNX` 가 존재

- 메세지 전달과 프로세스 스케줄링을 위한 서비스 제공

<br>

**But,** 마이크로커널은 **가중된 시스템 기능 오버헤드 때문에 성능이 나빠짐**

두 개의 사용자 수준 서비스가 통신해야 하는 경우 별도의 주소 공간에 서비스가 존재하기 때문에 메세지가 복사되어야 함

또한 운영체제는 메세지를 교환하기 위해 한 프로세스에서 다음 프로세스로 전환해야 할 수도 있음

**메세지 복사 및 프로세스 전환과 관련된 오버헤드는** 마이크로커널 기반 운영체제의 성장에 가장 큰 **장애**

<br>
<br>

### 4. 모듈

현재 운영체제 설계에 가장 좋은 방법 중 하나는 **적재가능 커널 모듈(LKM)**

여기서 커널은 핵심 구성 요소를 갖고 있으며, 부팅 시 또는 실행 중 모듈을 추가로 링크할 수 있음

- 이런 유형의 설계는 `Linux` , `MacOS X` , `Solaris` 및 `Windows` 등 현대 `UNIX` 를 구현하는 일반적 추세

<br>

핵심은 **커널이 핵심 서비스를 제공하고, 다른 서비스들은 커널이 실행되는 동안 동적으로 구현**하는 것

**서비스를 동적으로 링크**하는 것은 새로운 기능을 직접 추가하는 것보다 **바람직함**

- 후자의 경우, 수정 사항이 생길 때마다 커널을 다시 컴파일해야 함

<br>

전체 결과는 각 커널 섹션이 정의된, 보호된 인터페이스를 가진다는 점에서 **계층형 시스템과 유사**
**But, 모듈에서 임의의 다른 모듈을 호출할 수 있다는 점에서 계층 구조보다 유연함**

또한 **마이크로커널 접근 방식과 유사**하며 주요 모듈은 핵심 기능과 다른 모듈을 호출하고, 통신하는 방법을 알고 있지만 모듈이 **통신하기 위해 메세지 전달을 호출할 필요가 없기 때문에** 더 효율적

<br>

`Linux` 는 주로 장치 드라이버와 파일 시스템을 지원하기 위해 적재 가능 커널 모듈을 사용

LKM은 시스템이 부팅되거나 `USB` 장치가 실행 중인 시스템에 접속되는 경우와 같이 런타임 중에 커널에 **삽입** 될 수 있음

`Linux` 에 LKM을 사용하면 동적이고 모듈화된 커널을 유지하면서 모놀리식 시스템의 성능 이점을 유지할 수 있음

<br>
<br>

### 5. 하이브리드 시스템

실제로는 거의 모든 운영체제가 단일하게 정의된 구조를 채택하지 않음

대신 성능, 보안 및 사용 용이성 문제를 해결하는 하이브리드 시스템을 형성하기 위해 다양한 구조를 결합

예를 들어, `Linux` 는 모놀리식 구조이며, 운영체제를 단일 주소 공간에 두면 매우 효율적 성능을 제공

**But,** 이 운영체제들은 모듈을 사용하기 때문에 새로운 기능을 동적으로 커널에 추가할 수 있음

<br>

`Windows` 도 대체적으로 모놀리식 구조라 할 수 있지만, 사용자 모드 프로세스로 실행되는 별도의 **서브시스템(운영체제의 인격이라고 알려진)을 지원하는 일부 마이크로커널의 형식을 유지하고 있음**

또한 동적으로 적재가능 커널 모듈도 지원함

<br>
<br>

### 🧨 `Linux` 를 위한 `WINDOWS` 서브 시스템

`Windows` 는 다른 운영체제 환경을 흉내내기 위한 하이브리드 아키텍처를 사용

이 사용자 모드 서브시스템은 실제 서비스를 제공하기 위해 `Windows` 커널과 통신

`Window 10` 에는 네이티브 `Linux` 응용 프로그램이 `Windows 10` 에서 실행되도록 하는 **Windows Subsystem for Linux(WSL)**이 추가되었음

<br>

일반적 작동 방식은 사용자가 `Windows` 응용 프로그램 `bash.exe` 를 시작하고 사용자에게 `Linux` 를 실행하는 `bash` 셸을 사용자에게 제시

내부적으로 WSL 은 `init` 프로세스로 구성된 **`Linux` 인스턴스**를 생성해 `/bin/bash` 를 실행하는 `bash` 셸을 생성

이런 각 프로세스는 `Windows` **Pico** 프로세스에서 실행

<br>

Pico 프로세스는 가능한 한 `**Linux` 시스템 콜을 네이티브 `Windows` 시스템 콜로 변환함**

`Linux` 와 `Windows` 시스템 콜 간에 일대일 관계가 있는 경우, `**LXSS` 는 `Linux` 와 시스템 콜을 `Windows` 커널의 동등한 시스템 콜로 직접 전달**

상황에 따라 `Linux` 와 `Windows` 시스템 콜은 비슷하지만 **동일하지는 않음**

![Untitled 17](https://github.com/SeoYunnn/TIL/assets/120713987/b94749f7-04c1-477d-9fc5-2c4d1598e928)

<br>
<br>

## 💭 운영체제 빌딩과 부팅

하나의 특정 기기 구성에 맞게 운영체제를 설계, 코딩 및 구현할 수 있음

**But,** 보다 일반적으로 운영체제는 다양한 주변장치 구성을 가진 모든 종류의 컴퓨터에서 실행되도록 설계됨

<br>
<br>

### 2. 시스템 부트

운영체제가 생성된 후에는 하드웨어에서 새 운영체제를 사용할 수 있어야 함

<br>

**🤔 하드웨어는 커널의 위치 또는 커널을 적재하는 방법을 어떻게 알 수 있을까 ?**

👉🏻 **시스템 부팅 :** 커널을 적재해 컴퓨터를 시작하는 과정

<br>

**`[시스템 대부분에서 부팅 과정]`**

```bash
1) 부트스트랩 프로그램 또는 부트 로더라고 불리는 작은 코드가 커널의 위치를 찾음

2) 커널이 메모리에 적재되고 시작됨

3) 커널은 하드웨어를 초기화

4) 루트 파일 시스템이 마운트
```

<br>

일부 컴퓨터 시스템은 다단계 부팅 과정을 사용하는데, 컴퓨터 전원을 처음 켜면 **BIOS**라 하는 **비휘발성 펌웨어에 있는 소형 부트 로더가 실행**됨

이 초기 부트 로더는 일반적으로 **부트 블록**이라고 하는 **디스크의 정해진 위치에 있는 두 번째 부트 로더를 적재하는 작업**만 함

<br>

최신 컴퓨터 시스템이 BIOS 기반 부팅 과정을 **UEFI(Unified Extensible Firmware Interfcae)로 대체**하였음

64비트 시스템과 시스템 용량이 큰 디스크를 더 잘 지원하는 것을 포함해 몇 가지 장점을 지니고 있음

그 중 가장 큰 장점은 **다단계 BIOS 부팅 과정보다 빠름**

<br>

부트스트랩 프로그램은 BIOS에서 부팅하든 UEFI에서 부팅하든, 다양한 작업을 수행할 수 있음

커널 프로그램이 포함된 파일을 메모리에 적재하는 것 외에도 진단을 실시하여 메모리와 CPU를 점검하고 장치 검색과 같은 시스템 상태를 확인함

진단을 통과하면 프로그램은 부팅 과정을 계속 진행할 수 있음

부트스트랩은 CPU 레지스터에서 장치 컨트롤러 및 메인 메모리의 내용이 이르기까지 시스템의 모든 측면을 초기화 할 수 있음

운영체제를 시작하고 루트 파일 시스템을 마운트 하게 되는 이 시점에서 **시스템이 실행 중** 이라고 말할 수 있음

<br>

**GRUB**는 `Linux` 및 `UNIX` 시스템 을 위한 **공개 소스 부트스트랩 프로그램**

시스템의 부트 매개변수는 GRUB 구성 파일에 설정되며 실행 시작 시점에 적재됨

<br>
<br>

공간을 절약하고 부팅 시간을 줄이기 위해 `Linux` 커널 이미지는 압축 파일이며, 메모리에 적재된 후 압축이 풀어지는데 부팅 과정에서 부트 로더는 일반적으로 `initramfs` 로 알려진 임시 RAM 파일 시스템을 생성

이 파일 시스템에는 실제 루트 파일 시스템을 지원하기 위해 설치해야 하는 드라이버와 커널 모듈이 저장되어 있음

커널이 시작되고 필요한 드라이버가 설치되면 커널은 루트 파일 시스템을 임시 RAM 위치에서 적절한 루트 파일 시스템 위치로 전환함

마지막으로, `Linux` 는 시스템의 초기 프로세스인 `systemd` 프로세스를 생성한 다음 다른 서비스를 시작

<br>

모바일 시스템의 부팅 과정은 기존 PC의 부팅 과정과는 약간 다른데, 예로 커널은 `Linux` 기반이지만 `Android`는 `GRUB` 을 사용하지 않고 대신 부트 로더의 제공을 벤더에게 맡김

가장 일반적인 `Android` 부트 로더는 LK(작은 커널)

`Android` 시스템은 초기 RAM 파일 시스템 뿐 아니라 `Linux` 와 동일한 압축 커널 이미지를 사용

**But,** `Linux` 는 필요한 드라이버가 모두 적재되면 `initramfs` 를 폐기하지만 `Android` 는 `initramfs` 를 장치의 루트 파일 시스템으로 유지

커널이 적재되고 루트 파일 시스템이 마운트 되면 `Android` 는 `init` 프로세스를 시작하고 홈 화면을 표시하기 전 여러 서비스를 생성함

<br>

마지막으로, `Windows` , `Linux` 및 `macOS` 와 `iOS` 및 `Android` 를 비롯한 대부분 운영체제의 부트 로더는 하드웨어 문제 진단, 손상된 파일 시스템 복구 및 운영체제 재설치 등의 작업을 할 수 있는 **복구 모드** 또는 **단일 사용자 모드(안전 모드)**로 부팅할 수 있는 기능을 제공함
