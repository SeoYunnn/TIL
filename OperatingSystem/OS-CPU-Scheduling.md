# Chapter 05 CPU 스케줄링

## 💭 CPU 스케줄링이란 ?
📢 ***<span style="color:#0170a9"> CPU 스케줄링 : </span> 프로세스가 작업을 수행할 때, 언제 어떤 프로세스에 CPU를 할당할 지를 결정하는 작업
<br/> ✔️ <span style="color:#808080"> 운영체제가 CPU를 효율적으로 활용하기 위한 방법
<br/> ✔️ 여러 프로세스들 중 어떤 프로세스를 먼저 실행할 지, 얼마나 오랫동안 실행할 지를 결정하는 일련의 과정***</span>

<br>
<br>

### 1. CPU-I/O 버스트 사이클

CPU 스케줄링의 성공은 프로세스들의 다음과 같은 관찰된 성질에 의해 구분됨

- **CPU 실행**
- **I/O 대기 사이클**

프로세스들은 이들 두 상태 사이를 교대로 이동함

프로세스 실행은 CPU 버스트로 시작되고, 그 후 I/O 버스트가 발생하고, 잇따라 또 다른 CPU 버스트가 발생하고 또 다른 I/O 버스트로 진행

마지막 CPU 버스트는 또 다른 I/O 버스트가 뒤따르는 대신, 실행을 종료하기 위해 시스템 요청과 함께 끝남

<img width="586" alt="image" src="https://github.com/SeoYunnn/TIL/assets/120713987/f88138b9-8094-4842-be72-f37a138e3cb8">

<img width="628" alt="image" src="https://github.com/SeoYunnn/TIL/assets/120713987/7d8802e1-a68d-436b-ab8a-c464309d6fc0">

CPU 버스트들의 지속 시간을 측정한 결과 이들은 프로세스나 컴퓨터마다 변화가 크지만, 그림처럼 유사한 빈도수 곡선을 갖는 경향이 있음

짧은 CPU 버스트가 많이 있고 긴 CPU 버스트는 적음

I/O 중심의 프로그램은 전형적으로 짧은 CPU 버스트를 많이 가질 것이라고 예상됨

CPU 지향 프로그램은 다수의 긴 CPU 버스트를 가질 수 있는데 이러한 분포는 CPU 스케줄링 알고리즘을 구현할 때 매우 중요할 수 있는 사항

<br>
<br>

### 2. CPU 스케줄러

CPU가 유휴 상태가 될 때마다, 운영체제는 준비 큐에 있는 프로세스 중 하나를 선택해 실행

선택 절차는 CPU 스케줄러에 의해 수행되는데, 스케줄러는 실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택해 이들 중 하나에게 CPU를 할당

**<span style="color:#0170a9"> 준비 큐**는 **반드시 선입선출(FIFO) 방식의 큐가 아니어도 되는 것에 유의**해야 함

여러 가지 스케줄링 알고리즘들을 고려할 때 알게 되겠지만, **준비 큐**는 **선입선출 큐, 우선순위 큐, 트리 또는 단순히 순서가 없는 연결리스트**로 구현할 수 있음

**But,** 개념적으로는 준비 큐에 있는 모든 프로세스가 CPU에서 실행할 차례를 기다리며 줄을 서 있는 것으로 생각할 수 있음

큐 안에 있는 레코드는 일반적으로 프로세스의 PCB로 구성되어 있음

### 3. 선점 및 비선점 스케줄링

CPU 스케줄링 결정은 네 가지 상황에서 발생할 수 있음

***1) 한 프로세스가 실행 상태에서 대기 상태로 전환***

ex) I/O 요청이나 자식 프로세스가 종료되기를 기다리기 위해 `wait()` 를 호출할 때

***2) 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때***

ex) 인터럽트가 발생

***3) 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때***

ex) I/O 종료

***4) 프로세스가 종료할 때***

상황 1, 4의 경우에는 스케줄링 면에서는 선택의 여지가 없음

실행을 위해 새로운 프로세스(준비 큐에 하나라도 존재할 경우)가 반드시 선택되어야 함

반면, 상황 2, 3은 선택의 여지가 있음

상황 1과 4에서만 스케줄링이 발생할 경우에는 ***“비선점”*** 또는 ***“협조적”*** 이라 함

그렇지 않은 상황이라면 ***“선점”*** 이라 함

비선점 스케줄링에서는, CPU가 한 프로세스에 할당되면 프로세스가 종료하든지 또는 대기 상태로 전환해 CPU를 방출할 때까지 점유함

- `Windows`, `macOS`, `Linux` 및 `UNIX` 를 포함한 거의 모든 최신 운영체제들은 선점 스케줄링 알고리즘을 사용함

**But, 선점 스케줄링**은 데이터가 다수의 프로세스에 의해 공유될 때 **경쟁 조건을 초래할 수 있음**

또한 **운영체제 커널 설계에 영향**을 미침

시스템 콜을 처리할 동안, 커널은 한 프로세스를 위한 활동(I/O 큐와 같은)으로 바쁠 수 있음

이런 활동은 중요한 커널자료 변경을 포함할 수 있는데 변경 도중에 해당 프로세스가 선점되고 커널이 동일한 구조를 읽거나 변경할 필요가 있으면 지속적으로 혼란이 야기될 수 있음

운영체제 커널은 선점 또는 비선점 방식으로 설계될 수 있음

비선점형 커널은 문맥 교환을 하기 전 시스템 콜이 완료되거나 입출력 완료를 기다리며 프로세스가 봉쇄되기를 기다림

커널 자료구조가 비일관적인 상태에 있을 때 커널이 해당 프로세스를 선점하지 않기 때문에, 이런 방법은 커널 구조를 단순하게 만들음

😡 이러한 커널 실행 모델은 **주어진 시간 안에 태스크의 실행이 완료되어야 하는 실시간 컴퓨팅을 지원하기에는 좋은 모델이 아님**

선점형 커널에는 공유 커널 데이터 구조에 액세스 할 때 경쟁 조건을 방지하기 위해 mutex 락과 같은 기법 필요

대부분 최신 운영체제는 이제 커널 모드에서 실행될 때 완전히 선점될 수 있음

인터럽트는 어느 시점에서건 일어날 수 있고, 커널에 의해서 항상 무시될 수는 없기 때문에 인터럽트에 의해서 영향을 받는 코드 부분은 반드시 동시 사용으로부터 보호되어야 함

운영체제는 거의 항상 인터럽트를 받아들일 필요가 있는데, 그렇지 않으면 입력을 잃어버리거나 또는 출력이 겹쳐서 쓰일 수 있음

이러한 코드 부분은 다수 프로세스가 병행으로 접근할 수 없도록 그 진입점에서 인터럽트를 불능화하고 출구에서 인터럽트를 다시 가능화함

### 4. 디스패처

<aside>
📢 ***디스패처(dispatcher) : CPU 코어의 제어를 CPU 스케줄러가 선택한 프로레스에 주는 모듈이며, 다음과 같은 작업을 포함
✔️ 한 프로세스에서 다른 프로세스로 문맥을 교환하는 일
✔️ 사용자 모드로 전환하는 일
✔️ 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동하는 일***

</aside>

디스패처는 모든 프로세스의 문맥 교환 시 호출되므로, **가능한 한 최고로 빨리 수행**되어야 함

디스패처가 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는데까지 소요되는 시간을 ***“디스패치 지연”***

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c8d56e24-9d27-417a-87ef-ec824f9dc5be/1fb9e29a-2b08-4bd9-a8cb-4a5ce9609c4d/Untitled.png)

시스템 차원에서 `Linux` 시스템에서 제공되는 `vmstat` 명령을 사용하면 문맥 교환 횟수를 얻을 수 있음

```bash
vmstat 1 3 // 1-초 지연 단위로 3줄의 출력 제공
```

문맥교환은 두 가지로 구분 됨

- **자발적 문맥 교환 :** 현재 사용 불가능한 자원을 요청했기 때문에 프로세스가 CPU 제어를 포기한 경우 발생
- **비자발적 문맥 교환 :** 타임 슬라이스가 만료되었거나 우선순위가 더 높은 프로세스에 의해 선점된 경우와 같이 CPU 를 빼앗겼을 때 발생